locate command (like grep) only supports POSIX BRE (basic regular exp) not extended regular exp. 
This means alternations (like cat|dog|foo )is not supported.
There is need for escape/backslash characters for ( and )
Examples:
The BRE a{1,2} matches a{1,2} literally, while
a\{1,2\} matches a or aa
Tokens can be grouped with \( and \)
Backreferences are the usual \1 through \9. Only up to 9 groups are permitted. E.g. \(ab\)\1 matches abab
. * ^ $ work
Negation using ^ works only inside a [], so hsl[^/*] matches hsl_foo.c
anvi*pass* does NOT work but anvi.*pass.* works
Also hsl[^/]*$ matches blah/hsl_foo.c but not hsl/foo.c
Backslash is NOT a metacharacter in a POSIX bracket expression ([ and ]). 
So in POSIX, the regular expression [\d] matches a \ or a d. 
To match a ], put it as the first character after the opening [ or the negating ^. 
To match a -, put it right before the closing ]. 
To match a ^, put it before the final literal - or the closing ]. 
Put together, []\d^-] matches ], \, d, ^ or -. 

=====================================================================

http://www.delorie.com/gnu/docs/gawk/gawk_28.html

[] means characters inside are treated as a set, [ch] means either 'c' or 'h'
----

Next: Character Lists, Previous: Escape Sequences, Up: Regexp

2.3 Regular Expression Operators

You can combine regular expressions with special characters, called regular expression operators or metacharacters, to increase the power and versatility of regular expressions.

The escape sequences described earlier in Escape Sequences, are valid inside a regexp. They are introduced by a ‘\’ and are recognized and converted into corresponding real characters as the very first step in processing regexps.

Here is a list of metacharacters. All characters that are not escape sequences and that are not listed in the table stand for themselves:

\
This is used to suppress the special meaning of a character when matching. For example, ‘\$’ matches the character ‘$’.


^
This matches the beginning of a string. For example, ‘^@chapter’ matches ‘@chapter’ at the beginning of a string and can be used to identify chapter beginnings in Texinfo source files. The ‘^’ is known as an anchor, because it anchors the pattern to match only at the beginning of the string.
It is important to realize that ‘^’ does not match the beginning of a line embedded in a string. The condition is not true in the following example:

          if ("line1\nLINE 2" ~ /^L/) ...


$
This is similar to ‘^’, but it matches only at the end of a string. For example, ‘p$’ matches a record that ends with a ‘p’. The ‘$’ is an anchor and does not match the end of a line embedded in a string. The condition in the following example is not true:
          if ("line1\nLINE 2" ~ /1$/) ...


.
This matches any single character, including the newline character. For example, ‘.P’ matches any single character followed by a ‘P’ in a string. Using concatenation, we can make a regular expression such as ‘U.A’, which matches any three-character sequence that begins with ‘U’ and ends with ‘A’.
In strict POSIX mode (see Options), ‘.’ does not match the nul character, which is a character with all bits equal to zero. Otherwise, nul is just another character. Other versions of awk may not be able to match the nul character.



[...]
This is called a character list.1 It matches any one of the characters that are enclosed in the square brackets. For example, ‘[MVX]’ matches any one of the characters ‘M’, ‘V’, or ‘X’ in a string. A full discussion of what can be inside the square brackets of a character list is given in Character Lists.


[^ ...]
This is a complemented character list. The first character after the ‘[’ must be a ‘^’. It matches any characters except those in the square brackets. For example, ‘[^awk]’ matches any character that is not an ‘a’, ‘w’, or ‘k’.


|
This is the alternation operator and it is used to specify alternatives. The ‘|’ has the lowest precedence of all the regular expression operators. For example, ‘^P|[[:digit:]]’ matches any string that matches either ‘^P’ or ‘[[:digit:]]’. This means it matches any string that starts with ‘P’ or contains a digit.
The alternation applies to the largest possible regexps on either side.



(...)
Parentheses are used for grouping in regular expressions, as in arithmetic. They can be used to concatenate regular expressions containing the alternation operator, ‘|’. For example, ‘@(samp|code)\{[^}]+\}’ matches both ‘@code{foo}’ and ‘@samp{bar}’. (These are Texinfo formatting control sequences. The ‘+’ is explained further on in this list.)


*
This symbol means that the preceding regular expression should be repeated as many times as necessary to find a match. For example, ‘ph*’ applies the ‘*’ symbol to the preceding ‘h’ and looks for matches of one ‘p’ followed by any number of ‘h’s. This also matches just ‘p’ if no ‘h’s are present.
The ‘*’ repeats the smallest possible preceding expression. (Use parentheses if you want to repeat a larger expression.) It finds as many repetitions as possible. For example, ‘awk '/\(c[ad][ad]*r x\)/ { print }' sample’ prints every record in sample containing a string of the form ‘(car x)’, ‘(cdr x)’, ‘(cadr x)’, and so on. Notice the escaping of the parentheses by preceding them with backslashes.



+
This symbol is similar to ‘*’, except that the preceding expression must be matched at least once. This means that ‘wh+y’ would match ‘why’ and ‘whhy’, but not ‘wy’, whereas ‘wh*y’ would match all three of these strings. The following is a simpler way of writing the last ‘*’ example:
          awk '/\(c[ad]+r x\)/ { print }' sample


?
This symbol is similar to ‘*’, except that the preceding expression can be matched either once or not at all. For example, ‘fe?d’ matches ‘fed’ and ‘fd’, but nothing else.


{n}
{n,}
{n,m}
One or two numbers inside braces denote an interval expression. If there is one number in the braces, the preceding regexp is repeated n times. If there are two numbers separated by a comma, the preceding regexp is repeated n to m times. If there is one number followed by a comma, then the preceding regexp is repeated at least n times:
wh{3}y
Matches ‘whhhy’, but not ‘why’ or ‘whhhhy’. 
wh{3,5}y
Matches ‘whhhy’, ‘whhhhy’, or ‘whhhhhy’, only. 
wh{2,}y
Matches ‘whhy’ or ‘whhhy’, and so on.
Interval expressions were not traditionally available in awk. They were added as part of the POSIX standard to make awk and egrep consistent with each other.

However, because old programs may use ‘{’ and ‘}’ in regexp constants, by default gawk does not match interval expressions in regexps. If either --posix or --re-interval are specified (see Options), then interval expressions are allowed in regexps.

For new programs that use ‘{’ and ‘}’ in regexp constants, it is good practice to always escape them with a backslash. Then the regexp constants are valid and work the way you want them to, using any version of awk.2

In regular expressions, the ‘*’, ‘+’, and ‘?’ operators, as well as the braces ‘{’ and ‘}’, have the highest precedence, followed by concatenation, and finally by ‘|’. As in arithmetic, parentheses can change how operators are grouped.

In POSIX awk and gawk, the ‘*’, ‘+’, and ‘?’ operators stand for themselves when there is nothing in the regexp that precedes them. For example, ‘/+/’ matches a literal plus sign. However, many other versions of awk treat such a usage as a syntax error.

If gawk is in compatibility mode (see Options), POSIX character classes and interval expressions are not available in regular expressions.

Footnotes

[1] In other literature, you may see a character list referred to as either a character set, a character class, or a bracket expression.

[2] Use two backslashes if you're using a string constant with a regexp operator or function.


====

2.8 Using Dynamic Regexps

The righthand side of a ‘~’ or ‘!~’ operator need not be a regexp constant (i.e., a string of characters between slashes). It may be any expression. The expression is evaluated and converted to a string if necessary; the contents of the string are used as the regexp. A regexp that is computed in this way is called a dynamic regexp:

     BEGIN { digits_regexp = "[[:digit:]]+" }
     $0 ~ digits_regexp    { print }
This sets digits_regexp to a regexp that describes one or more digits, and tests whether the input record matches this regexp.

Caution: When using the ‘~’ and ‘!~’ operators, there is a difference between a regexp constant enclosed in slashes and a string constant enclosed in double quotes. If you are going to use a string constant, you have to understand that the string is, in essence, scanned twice: the first time when awk reads your program, and the second time when it goes to match the string on the lefthand side of the operator with the pattern on the right. This is true of any string-valued expression (such as digits_regexp, shown previously), not just string constants.

What difference does it make if the string is scanned twice? The answer has to do with escape sequences, and particularly with backslashes. To get a backslash into a regular expression inside a string, you have to type two backslashes.

For example, /\*/ is a regexp constant for a literal ‘*’. Only one backslash is needed. To do the same thing with a string, you have to type "\\*". The first backslash escapes the second one so that the string actually contains the two characters ‘\’ and ‘*’.

Given that you can use both regexp and string constants to describe regular expressions, which should you use? The answer is “regexp constants,” for several reasons:

String constants are more complicated to write and more difficult to read. Using regexp constants makes your programs less error-prone. Not understanding the difference between the two kinds of constants is a common source of errors.
It is more efficient to use regexp constants. awk can note that you have supplied a regexp and store it internally in a form that makes pattern matching more efficient. When using a string constant, awk must first convert the string into this internal form and then perform the pattern matching.
Using regexp constants is better form; it shows clearly that you intend a regexp match.
====
