
int x = -2147483648;
this is 2^31 , highest value of int
when you do x = -x or  x *= -1, value of x remains unchanged at -2147483648!
use: unsigned int xx = (x < 0) ? -x : x; 

==
static_cast<char>(5) will not give you '5'. for that do static_cast<char>(5 + '0')
also, static_cast<int>('5' - '0') will give you 5
https://stackoverflow.com/questions/49221393/static-cast-use-to-convert-int-to-char

==
Declare them in a private namespace ( a namespace with no name) in .cpp file. They are now only accessible at file scope. ( A good way to hide implementation detail, if the code is only needed in one .cpp file ).

==

https://stackoverflow.com/questions/17889916/c-is-the-same-passing-an-array-than-a-pointer-to-array

"decay" of array into pointers:

[] vs * (arrays):

First of all, arrays are not pointers.
...
Arrays and pointers are only the same when declared as function arguments.
...
In the pointer-to-array case you need to specify the size of the array, 
...

https://stackoverflow.com/questions/1461432/what-is-array-to-pointer-decay:
once decayed, sizeof no longer gives the complete array's size, because it essentially becomes a pointer. 

==

std::string by reference or not?

There are multiple answers based on what you are doing with the string.

1) Using the string as an id (will not be modified). Passing it in by const reference is probably the best idea here: (std::string const&)

2) Modifying the string but not wanting the caller to see that change. Passing it in by value is preferable: (std::string)

3) Modifying the string but wanting the caller to see that change. Passing it in by reference is preferable: (std::string &)

4) Sending the string into the function and the caller of the function will never use the string again. Using move semantics might be an option (std::string &&)

https://stackoverflow.com/questions/10789740/passing-stdstring-by-value-or-reference

==

placement params in 'new' operator:
Syntax
::(optional) new (placement_params)(optional) ( type ) initializer(optional)	(1)	
::(optional) new (placement_params)(optional) type initializer(optional)

==


std::atomic template for thread safety

==

what is bool(someobject)?
https://stackoverflow.com/questions/4600295/what-is-the-meaning-of-operator-bool-const

==

? operator casts, it promotes. result[0] is a SEXP with one element, it gets casted to a list, like result.

return result.size() == 1 ? result[0] : result;

do, if (...) ... instead of "?"

==

lambda

https://stackoverflow.com/questions/4324763/can-we-have-functions-inside-functions-in-c

==

Why can I not push_back a unique_ptr into a vector?
https://stackoverflow.com/questions/3283778/why-can-i-not-push-back-a-unique-ptr-into-a-vector

==

However, even if you allocate excess memory you still can't validly access members outside of the array bounds of one element. The behaviour is undefined; a C++ implementation would be within its rights to add bounds checking according to the actual type of the object constructed. â€“ CB Bailey Dec 10 '10 at 21:14

https://stackoverflow.com/questions/4412749/are-flexible-array-members-valid-in-c

==

struct OneState {
     uint32_t matchcond;   // conditions to match right now.
     uint32_t action[];
   };

sizeof(OneState) is 4, because action[] has zero length

struct OneState2 {
     uint32_t matchcond;   // conditions to match right now.
     uint32_t *action;
   };

sizeof(OneState2) is 16. pointer length is 8 and compiler pads 4 bytes.

https://stackoverflow.com/questions/45575808/alternative-to-flexible-array-member-without-dynamic-memory-allocation

==

std::allocator vs new:
https://stackoverflow.com/questions/31358804/whats-the-advantage-of-using-stdallocator-instead-of-new-in-c

==
pointer arithmatic:
https://www.learncpp.com/cpp-tutorial/pointer-arithmetic-and-array-indexing/

Note that ptr + 1 does not return the memory address after ptr, but the memory address of the next object of the type that ptr points to.

When calculating the result of a pointer arithmetic expression, the compiler always multiplies the integer operand by the size of the object being pointed to. This is called scaling.

==
