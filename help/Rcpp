make -f make.util buildR

sandbox> cd re2 && Rscript -e 'library(Rcpp);compileAttributes()' && cd .. && R CMD INSTALL re2


R CMD INSTALL re2 && Rscript --default-packages=re2 -e "rcpp_hello_world()"

R CMD INSTALL re2 -clean
make -f Mk.clean  clean

cd re2 && Rscript -e 'library(Rcpp);compileAttributes()'

# backup:
cd /Users/gp/sandbox/re2
tar -c --exclude-from=.gitignore -vzf re2.tar.gz *
gscp re2.tar.gz vm-free:~/bak/
rm -f re2.tar.gz


rcpp examples
https://github.com/eddelbuettel/rcppexamples/tree/master/src

rinside examples
https://github.com/eddelbuettel/rinside/tree/master/inst/examples/standard

==
a good book:
http://adv-r.had.co.nz/C-interface.html

Character vectors and lists Strings and lists are more complicated
because the individual elements of a vector are SEXPs, not basic C
data structures. Each element of a STRSXP is a CHARSXPs, an immutable
object that contains a pointer to C string stored in a global
pool. Use STRING_ELT(x, i) to extract the CHARSXP, and
CHAR(STRING_ELT(x, i)) to get the actual const char* string. Set
values with SET_STRING_ELT(x, i, value). Use mkChar() to turn a C
string into a CHARSXP and mkString() to turn a C string into a
STRSXP. Use mkChar() to create strings to insert in an existing
vector, use mkString() to create a new (length 1) vector.

also:
https://stackoverflow.com/questions/34056265/converting-an-sexp-from-r-into-a-vector-of-strings-in-c

==

XXX
namespace re2 weirdness: does not find re2_re2wrapper methods.

==

https://dirk.eddelbuettel.com/papers/rcpp_rfinance_may2012.pdf

==

SEXP to char* underneath:
https://stackoverflow.com/questions/34056265/converting-an-sexp-from-r-into-a-vector-of-strings-in-c

==

NA, NaN, Inf,...
https://teuder.github.io/rcpp4everyone_en/240_na_nan_inf.html

==
Don't use push_back on Rcpp types. The way Rcpp vectors are
currently implemented this requires copying all of the data each
time. This is a very expensive operation.

https://stackoverflow.com/questions/19823915/how-can-i-handle-vectors-without-knowing-the-type-in-rcpp

==

defns http://dirk.eddelbuettel.com/code/rcpp/html/instantiation_8h_source.html

==

good book
https://teuder.github.io/rcpp4everyone_en/080_vector.html#push_back-x

xx(n) is better than xx[n] for rcpp since former throws
exception on out of bounds

==

no .reserve() in vector, because: 
https://stackoverflow.com/questions/13782943/how-to-resize-a-numericvector

==



Rcpp::String vs std::string : no copy

https://stackoverflow.com/questions/32193984/what-is-the-benefit-of-having-a-string-class-for-rcpp

==


by val or reference?

a NumericVector behaves as a pointer in the C++ functions. The pointer
gives you the address where the values are stored, and to be able to
change the values at that address, you only need to know the address,
but you don't need the ability to modify the address
itself. Therefore, there is no difference in passing the pointer by
value or passing it by reference.

https://stackoverflow.com/questions/49272396/difference-between-value-and-reference-args-in-rcpp

==

deepcopy:
Rcpp::as<>() from StringVector to std::string causes deepcopy
Rcpp::wrap() is shallow copy of pointer to memory (fast)

==

sed :
https://stackoverflow.com/questions/2777579/how-to-output-only-captured-groups-with-sed
 ==


Accessing vector elements You can access an individual element of a
vector object using [] or () operator. Both operators accept
NumericVector/IntegerVector (numerical index), CharacterVector
(element names) and LogicalVector. [] operator ignores out of bound
access, while () operator throws an exception index_out_of_bounds.

https://teuder.github.io/rcpp4everyone_en/080_vector.html#member-functions-vector

==

mylist <- list(A = 1:10, B = letters[1:10])
nullable3(mylist, NULL)

==

5.13 of https://cran.r-project.org/doc/manuals/r-release/R-exts.html#External-pointers-and-weak-references

External pointer SEXPs are intended to handle references to C
structures such as ‘handles’, and are used for this purpose in package
RODBC for example. They are unusual in their copying semantics in that
when an R object is copied, the external pointer object is not
duplicated. (For this reason external pointers should only be used as
part of an object with normal semantics, for example an attribute or
an element of a list.)

It is probably not a good idea to allow an external pointer to be
saved and then reloaded, but if this happens the pointer will be set
to the C NULL pointer.

==

auto

  for (auto it = 0; it != input.size(); it++) {
 196       auto rstr = STRING_ELT(inputx, it);
 197       if (rstr == NA_STRING) {
 198         SET_STRING_ELT(res, it, NA_STRING);
 199         continue;
 200       }
 201

==

read 1.2.1 Using Makevars
https://edoras.sdsu.edu/doc/R/manual/R-exts.html

==
union {
      struct {
      } foo;
}
above passes Wpedantic with debian, but not on osx
you have to name the struct, as struct xxx {. But naming
struct is not possible inside anonymous union.
so name the union also.

https://stackoverflow.com/questions/46056697/why-do-i-get-the-anonymous-type-warning-for-this-code
https://stackoverflow.com/questions/16202576/c-anonymous-structs

==

you changed foo[]; declarations to foo[1].
If you look he uses new () space; to create objects in the preallocated memory 'space'
this memory will be released when execution falls through the scope
so no worries allocating extra object initially, it will be overwritten anyway.

==

XXX
need to do this on linux: https://stackoverflow.com/questions/3001177/how-do-i-grep-for-all-non-ascii-characters

grep --color='auto' -P -n "[\x80-\xFF]" file

==

parallelism

https://stackoverflow.com/questions/37167479/rcpp-parallelize-functions-that-return-xptr

- not clear if you can use XPtr in parallel threads (seems no).
- rcppparallel (see link inside dirk's answer, provide parallelFor but not clear
how you'd pass a compiled RE object (needs expternal pointer that is persistent)

from rcppparallel:
API Restrictions
The code that you write within parallel workers should not call the R or Rcpp API in any fashion. This is because R is single-threaded and concurrent interaction with it’s data structures can cause crashes and other undefined behavior. Here is the official guidance from Writing R Extensions:

Calling any of the R API from threaded code is ‘for experts only’: they will need to read the source code to determine if it is thread-safe. In particular, code which makes use of the stack-checking mechanism must not be called from threaded code.

Not being able to call the R or Rcpp API creates an obvious challenge: how to read and write to R vectors and matrices. Fortunately, R vectors and matrices are just contiguous arrays of int, double, etc. so can be accessed using traditional array and pointer offsets. The next section describes a safe and high level way to do this.

libdispatch GCD vs intel TBB

http://meanmean.me/
About a decade late, but I decided to give Grand Central Dispatch (GCD) a go in R. GCD is fairly similar to OpenMP as it provides a simplified interface for pthreads. Since its release for Mac OS X 10.6 in 2009, GCD has been ported to a number of operating systems through libdispatch. As of this writing, libdispatch is primarily available on Linux and Apple's operating systems using the Clang compiler. GCC may work, but I have not had any luck.

https://stackoverflow.com/questions/2144639/does-pthreads-provide-any-advantages-over-gcd

==

C++ to R

https://stackoverflow.com/questions/7457635/calling-r-function-from-c

==

If you have function xxx(). You can run its examples by example(xxx), and
open its doc by ?xxx or help(xxx)

==

XXX: When writing a Makevars file for a package you intend to distribute, take care to ensure that it is not specific to your compiler: flags such as -O2 -Wall -pedantic are all specific to GCC.

==

to turn on markdown support:

Roxygen: list(markdown = TRUE)

==

roxygen replaces `x` with \verb{x}, not \code{}. Things under \code{} are
checked for R syntax errors. \verb is just verbatim but displayed in
typewriter font

==

There are two aspects here:

Have the C++ function callable from R. You need the // [[Rcpp::export]] tag for that, and it will create an R interface.

Have that R/C++ interface function 'visible' to clients of the package. That is different and controlled by NAMESPACE. Just do not list it there, only list your other function. You can still call it from the outside by using the colons: yourpackage:::yourCppFunction().

That way your C++ code is callable (per 1.) and does not need an Rd file (per 2. as it is not exported.) Only your visible R wrapper needs an man page entry.

https://stackoverflow.com/questions/46039132/renaming-and-hiding-an-exported-rcpp-function-in-an-r-package

==
notes:
r$> re2_extract("boris@kremvax.ru", "(.*)@([^.]*)", "\\2!\\1")
[1] "kremvax!boris"

r$> re2_replace("boris@kremvax.ru", "(.*)@([^.]*)", "\\2!\\1")
[1] "kremvax!boris.ru"

//' \Sexpr[echo=TRUE]{re2_max_submatch("foo \\2,\\1")}
 18 //' \Sexpr[echo=FALSE]{re2_max_submatch("foo \\4,\\1")}
 19 /

\seealso{
 115 \link{re2_replace}, \link{re2_global_replace}, \link{re2_match}, \link{re2_extract}.
 116 }

//' \Sexpr[stage=render, results=rd]{ paste(re2_capturing_group_names("((abc)(?P<G2>)|((e+)(?P<G2>.*)(?P<G1>u+)))") , collapse=',')}
//'

//' \dontshow{
//' stopifnot(re2_max_submatch("foo \\2,\\1") == 2)
//' }
//' stopifnot(re2_max_submatch("bar \\2: \\5") == 5)
//' \re2example{re2_max_submatch("bar \\\\2: \\\\5")}
//' \Sexpr[stage=render, results=text]{ paste('> re2_max_submatch("bar \\2: \\5")') }
//' \Sexpr[stage=render, results=rd]{ re2_max_submatch("bar \\2: \\5") }
//' stopifnot(re2_max_submatch(c("bar \\2: \\5", r"(\1 \9)")) == c(5, 9))

//' @param \dots If \verb{logical=TRUE} or \verb{l=T}, returns
//'   TRUE iff a match occurred and the extraction happened
//'   successfully. If \verb{verbose=TRUE} or \verb{v=T},
//'   character string or vector with extractions is returned along
//'   with logical TRUE/FALSE. In addition, options to
//'   \code{\link{re2_re2}} are also applicable.
//'

//' @section Output of Examples:
//' \Sexpr[stage=render, results=verbatim, echo=T]{re2_extract("bunny@wunnies.pl", "(.*)@([^.]*)", "\\\\2!\\\\1")}
//'
//' \Sexpr[stage=render, results=verbatim, echo=T]{re2_match(c("foo@dd", "bunny@wunnies.pl"), "(.*)@([^.]*)")}
//'

==

